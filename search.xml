<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot用户上下文注入]]></title>
    <url>%2F2019%2F08%2F20%2Fspringboot%E7%94%A8%E6%88%B7%E4%B8%8A%E4%B8%8B%E6%96%87%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[用户上下文注入 本文所用相关版本:springboot版本2.1.7.RELEASEkotlin版本1.2.71gradle版本5.2.1idea版本2019.1.2 ultimate edition 新建项目 点击file -&gt; new project -&gt;选择spring initializrd点击下一步 选择语言,选择项目管理工具 此篇讨论我们只进行数据模拟,不涉及实际数据,只引入springWebStarter进行请求测试即可 选择gradle路径(或者使用默认的),这里我选择本地路径 增加国内镜像地址 追加根节点 1234repositories &#123; maven (url = "http://maven.aliyun.com/nexus/content/groups/public/") jcenter()&#125; 增加fastJson依赖用以序列化 在dependencies中追加 1implementation("com.alibaba:fastjson:1.2.59") 重新导入等待编译完成 控制器注入使用方法解析器,我们能够在控制器中有选择的解析并注入参数 用户上下文对象和标记注解: 12345data class UserContext(val userId: String, val username: String)@Target(AnnotationTarget.VALUE_PARAMETER)@Retention(AnnotationRetention.RUNTIME)annotation class CurrentUser 配置方法解析器,给加上标记注解的UserContext对象自动解析请求头中的json信息并注入 1234567891011121314151617class CurrentUserMethodArgumentResolver : HandlerMethodArgumentResolver &#123; /** * 符合条件才进入此参数解析器 */ override fun supportsParameter(parameter: MethodParameter): Boolean &#123; return parameter.parameterType.isAssignableFrom(UserContext::class.java) &amp;&amp; parameter.hasParameterAnnotation(CurrentUser::class.java) &#125; /** * 参数解析并注入对象 */ override fun resolveArgument(parameter: MethodParameter, mavContainer: ModelAndViewContainer?, webRequest: NativeWebRequest, binderFactory: WebDataBinderFactory?): Any? &#123; val userJson = webRequest.getHeader("user-test") return JSON.parseObject(userJson, UserContext::class.java) &#125;&#125; 启用方法解析器 12345678910@Configurationclass SpringConfig : WebMvcConfigurer &#123; /** * 加入解析器列表 */ override fun addArgumentResolvers(resolvers: MutableList&lt;HandlerMethodArgumentResolver&gt;) &#123; super.addArgumentResolvers(resolvers) resolvers.add(CurrentUserMethodArgumentResolver()) &#125;&#125; 测试控制器 12345678@SpringBootApplication@RestControllerclass DemoApplication &#123; @GetMapping("/getArgument") fun getArgument(@CurrentUser userContext: UserContext):UserContext &#123; return userContext &#125;&#125; 编写WebMvc测试类测试结果 123456789101112131415@RunWith(SpringRunner::class)@WebMvcTest(DemoApplication::class)class WebMvcTest &#123; private val log = LoggerFactory.getLogger(this.javaClass) @Autowired lateinit var mockMvc: MockMvc @Test fun testGetArgument() &#123; val json = "&#123;\"username\":\"测试\", \"userId\":\"测试\"&#125;" mockMvc.perform(MockMvcRequestBuilders.get("/getArgument") .header("user-test", json)) .andExpect(status().isOk).andDo &#123; log.info("返回结果 $&#123;it.response.contentAsString&#125;") &#125;.andReturn() &#125;&#125; 测试结果 使用此方式我们可以很方便在需要时将用户上下文注入控制器中,并且只有需要时,才会进行参数解析 静态方法获取使用构造器注入的方式,不方便之处在于当我们在service层需要使用时,只能一层一层的向内传,对我们的方法参数造成的一定程度上的污染,我们可以利用线程安全的ThreadLocal对象在每次请求时存储用户上下文 RequestContext对象 123456789101112131415161718object RequestContext &#123; /** * 用户上下文 */ private val userContextThreadLocal: ThreadLocal&lt;UserContext&gt; = ThreadLocal() fun setUserContext(userContext: UserContext) &#123; userContextThreadLocal.set(userContext) &#125; fun getUserContext(): UserContext &#123; return userContextThreadLocal.get() &#125; fun removeUserContext() &#123; userContextThreadLocal.remove() &#125;&#125; 使用spring提供的HandlerInterceptor接口我们可以跟踪请求，解析参数，并及时释放本地线程中的对象 123456789101112131415161718192021class RequestInterceptor : HandlerInterceptor &#123; /** * 如果让请求继续执行则返回true */ override fun preHandle(request: HttpServletRequest, response: HttpServletResponse, handler: Any): Boolean &#123; val userJson = request.getHeader("user-test") if (userJson.isNullOrBlank()) &#123; return true &#125; RequestContext.setUserContext(JSON.parseObject(userJson, UserContext::class.java)) return super.preHandle(request, response, handler) &#125; /** * 请求结束时移除上下文，抛出异常也会执行 */ override fun afterCompletion(request: HttpServletRequest, response: HttpServletResponse, handler: Any, ex: Exception?) &#123; RequestContext.removeUserContext() &#125;&#125; 在spring中配置此拦截器 1234567/** * 加入拦截器列表 */override fun addInterceptors(registry: InterceptorRegistry) &#123; super.addInterceptors(registry) registry.addInterceptor(RequestInterceptor())&#125; 测试控制器 12345@GetMapping("/getStatic")fun getStatic(): UserContext &#123;// throw RuntimeException("啊偶 出错了") return RequestContext.getUserContext()&#125; 测试方法 1234567@Testfun testGetStatic() &#123; val json = "&#123;\"username\":\"测试1\", \"userId\":\"测试1\"&#125;" mockMvc.perform(MockMvcRequestBuilders.get("/getStatic") .header("user-test", json)) .andExpect(status().isOk).andDo &#123; log.info("返回结果 $&#123;it.response.contentAsString&#125;") &#125;.andReturn()&#125; 测试结果 由于提供的都是静态方法，使用此方式我们就可以在任何地方使用用户上下文对象(注意避免空指针)，例如，我们就可以使用mybatis拦截器替我们完成userId等属性的注入。 bean获取由于静态类不由spring管理，业务类使用时不免使代码的耦合性变强，当我们需要变更方案时将会比较麻烦，因此我们希望将类委托spring进行管理 方案1(单例bean) 我们提供一个接口，向外暴露一个getter方法，在getter方法中调用静态方法获取 12345interface UserContextManage &#123; fun getUserContext(): UserContext &#123; return RequestContext.getUserContext() &#125;&#125; 配置bean 1234@Beanfun userContextManage(): UserContextManage &#123; return object : UserContextManage &#123;&#125;&#125; 控制器 1234567@Autowiredlateinit var userContextManage: UserContextManage@GetMapping("/getSingletonBean")fun getSingletonBean(): UserContext &#123; return userContextManage.getUserContext()&#125; 测试方法 123456fun testGetSingletonBean() &#123; val json = "&#123;\"username\":\"测试3\", \"userId\":\"测试3\"&#125;" mockMvc.perform(MockMvcRequestBuilders.get("/getSingletonBean") .header("user-test", json)) .andExpect(status().isOk).andDo &#123; log.info("返回结果 $&#123;it.response.contentAsString&#125;") &#125;.andReturn()&#125; 测试结果 需要额外提及的是，当我们在业务层依赖此对象时，单元测试由于不涉及请求导致用户上下文为空，这里推荐使用mockBean进行测试 12345678910@MockBeanlateinit var userContextManage: UserContextManage@Beforefun before() &#123; Mockito.`when`(userContextManage.getUserContext()).thenReturn(UserContext("mock测试","mock测试"))&#125;@Testfun testMockSingletonBean() &#123; log.info(userContextManage.getUserContext().toString())&#125; mock结果 方案2(请求bean)spring为我们提供了scope为request的bean，例如httpServletRequest就是一个这种bean，这种类型的bean的生命周期和请求是息息相关的，伴随的请求开始和结束进行创建和销毁 声明bean 12345@Bean@Scope(WebApplicationContext.SCOPE_REQUEST)fun userContext(): UserContext &#123; return RequestContext.getUserContext()&#125; 控制器 123456@Autowired(required = false)var userContext: UserContext? = null@GetMapping("/getRequestBean")fun getRequestBean(): UserContext &#123; return userContext!!&#125; 测试方法 1234567@Testfun testGetRequestBean() &#123; val json = "&#123;\"username\":\"测试4\", \"userId\":\"测试4\"&#125;" mockMvc.perform(MockMvcRequestBuilders.get("/getRequestBean") .header("user-test", json)) .andExpect(status().isOk).andDo &#123; log.info("返回结果 $&#123;it.response.contentAsString&#125;") &#125;.andReturn()&#125; 在测试时我们会发现，哪怕我们不要求spring为我们一定要注入这个bean，spring还是会尝试注入并报错 这里有几种方案处理这种异常 方式1 引入javax inject依赖 1implementation("javax.inject:javax.inject:1") 控制器中注入对象使用Provider包装 123456@Autowiredlateinit var userContext: Provider&lt;UserContext&gt;@GetMapping("/getRequestBean")fun getRequestBean(): UserContext &#123; return userContext.get()&#125; 方式2 为bean使用代理 注意如果使用kotlin不要使用类代理，否则会丢失字段值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 使用kotlin需要配置消息转换器(java是否需要还未测试)@Beanfun httpMessageConverter(): HttpMessageConverter&lt;*&gt; &#123; //创建fastJson消息转换器 val fastConverter = FastJsonHttpMessageConverter() //升级最新版本需加============================================================= val supportedMediaTypes = ArrayList&lt;MediaType&gt;() supportedMediaTypes.add(MediaType.APPLICATION_JSON) supportedMediaTypes.add(MediaType.APPLICATION_JSON_UTF8) supportedMediaTypes.add(MediaType.APPLICATION_ATOM_XML) supportedMediaTypes.add(MediaType.APPLICATION_FORM_URLENCODED) supportedMediaTypes.add(MediaType.APPLICATION_OCTET_STREAM) supportedMediaTypes.add(MediaType.APPLICATION_PDF) supportedMediaTypes.add(MediaType.APPLICATION_RSS_XML) supportedMediaTypes.add(MediaType.APPLICATION_XHTML_XML) supportedMediaTypes.add(MediaType.APPLICATION_XML) supportedMediaTypes.add(MediaType.MULTIPART_FORM_DATA) supportedMediaTypes.add(MediaType.IMAGE_GIF) supportedMediaTypes.add(MediaType.IMAGE_JPEG) supportedMediaTypes.add(MediaType.IMAGE_PNG) supportedMediaTypes.add(MediaType.TEXT_EVENT_STREAM) supportedMediaTypes.add(MediaType.TEXT_HTML) supportedMediaTypes.add(MediaType.TEXT_MARKDOWN) supportedMediaTypes.add(MediaType.TEXT_PLAIN) supportedMediaTypes.add(MediaType.TEXT_XML) fastConverter.supportedMediaTypes = supportedMediaTypes //创建配置类 val fastJsonConfig = FastJsonConfig() //修改配置返回内容的过滤 //WriteNullListAsEmpty ：List字段如果为null,输出为[],而非null //WriteNullStringAsEmpty ： 字符类型字段如果为null,输出为"",而非null //DisableCircularReferenceDetect ：消除对同一对象循环引用的问题，默认为false（如果不配置有可能会进入死循环） //WriteNullBooleanAsFalse：Boolean字段如果为null,输出为false,而非null //WriteMapNullValue：是否输出值为null的字段,默认为false fastJsonConfig.setSerializerFeatures( SerializerFeature.DisableCircularReferenceDetect, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullStringAsEmpty, SerializerFeature.WriteMapNullValue ) fastConverter.fastJsonConfig = fastJsonConfig return fastConverter&#125; 修改用户上下文对象 123456open class UserContext(override val userId: String, override val username: String) : IUserContextinterface IUserContext &#123; val userId: String val username: String&#125; 接口代理 12345@Bean@Scope(WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.INTERFACES)fun iUserContext(): IUserContext &#123; return RequestContext.getUserContext()&#125; 控制器注入 123456@Autowiredlateinit var userContext: IUserContext@GetMapping("/getRequestBean")fun getRequestBean(): IUserContext &#123; return userContext&#125; 处理之后测试运行结果 此方式使用将bean委托spring管理，耦合性较低，并且如果使用代理的方式用起来会更加方便，但需要注意的是，由于使用了代理，在请求不涉及用户上下文(即获取用户上下文为空)的情况下调用代理对象将直接抛异常(无法使用==null做空判断) 代码链接]]></content>
      <categories>
        <category>kotlin web</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>gradle</tag>
        <tag>kotlin</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot处理集合类型校验]]></title>
    <url>%2F2019%2F07%2F25%2Fspringboot%E5%A4%84%E7%90%86%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[springboot处理集合类型校验 本文所用相关版本:springboot版本2.1.6.RELEASEkotlin版本1.2.71gradle版本5.2.1idea版本2019.1.2 ultimate edition 新建项目 点击file -&gt; new project -&gt;选择spring initializrd点击下一步 选择语言,选择项目管理工具 此篇我们讨论只涉及校验,只引入springWebStarter即可 选择gradle路径(或者使用默认的),这里我选择本地路径 输入项目路径,点击finish,查看项目结构,我们可以看到生成的gradle依赖文件变成了kts后缀的文件,和之前比起来,配置会略有不同 增加国内镜像地址 追加根节点 1234repositories &#123; maven (url = "http://maven.aliyun.com/nexus/content/groups/public/") jcenter()&#125; 重新导入等待编译完成 重现无法校验场景 增加测试控制器和测试类,这里我直接加在了启动类上 1234567891011121314151617181920212223@SpringBootApplication@RestControllerclass DemoApplication &#123; @PostMapping("/demo") fun demo(@RequestBody @Validated user: User): User &#123; return user &#125; @PostMapping("/demoList") fun demoList(@RequestBody @Validated user: List&lt;User&gt;): List&lt;User&gt; &#123; return user &#125;&#125;class User &#123; @NotBlank(message = "用户名不能为空") val username: String? = null val password: String? = null&#125;fun main(args: Array&lt;String&gt;) &#123; runApplication&lt;DemoApplication&gt;(*args)&#125; 增加测试类 12345678910111213141516171819202122@RunWith(SpringRunner::class)@WebMvcTest(DemoApplication::class)class WebMvcTest &#123; @Autowired lateinit var mockMvc: MockMvc @Test fun testDemo() &#123; val example = "&#123;\"username\":\"\", \"password\":\"111\"&#125;" mockMvc.perform(MockMvcRequestBuilders.post("/demo") .contentType(MediaType.APPLICATION_JSON_VALUE).content(example)) .andExpect(status().isOk).andDo &#123; println(it.response.contentAsString) &#125;.andReturn() &#125; @Test fun testDemoList() &#123; val example = "[&#123;\"username\":\"\", \"password\":\"111\"&#125;]" mockMvc.perform(MockMvcRequestBuilders.post("/demoList") .contentType(MediaType.APPLICATION_JSON_VALUE).content(example)) .andExpect(status().isOk).andDo &#123; println(it.response.contentAsString) &#125;.andReturn() &#125;&#125; 我们先执行能够正常执行校验的测试方法testDemo,执行后发现控制台报错,说明参数被校验了 但执行List时参数却未被校验 处理方案方案1: 新建类包装List,在list上加上@Valid(javax包中)(由于@Validated不支持放在字段上,所以无法使用)注解 控制器方法 1234@PostMapping("/demoValidList")fun demoValidList(@RequestBody @Validated user: ValidList&lt;User&gt;): List&lt;User&gt;? &#123; return user.list&#125; 包装类 1234class ValidList&lt;T&gt; &#123; @Valid val list: List&lt;T&gt;? = null&#125; 测试方法 1234567@Testfun testDemoValidList() &#123; val example = "&#123;\"list\":[&#123;\"username\":\"\", \"password\":\"111\"&#125;]&#125;" mockMvc.perform(MockMvcRequestBuilders.post("/demoValidList") .contentType(MediaType.APPLICATION_JSON_VALUE).content(example)) .andExpect(status().isOk).andDo &#123; println(it.response.contentAsString) &#125;.andReturn()&#125; 可以看到此方案需要我们将传输的参数变为对象,多了一层无用的嵌套,并且由于@Valid注解的缺陷,无法使用分组 方案2: 我们可以采用实现list接口并转接方法的方式,去掉这层无用的嵌套 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class ValidList1&lt;T&gt; : MutableList&lt;T&gt; &#123; override fun iterator(): MutableIterator&lt;T&gt; &#123; return list.iterator() &#125; override fun listIterator(): MutableListIterator&lt;T&gt; &#123; return list.listIterator() &#125; override fun listIterator(index: Int): MutableListIterator&lt;T&gt; &#123; return list.listIterator(index) &#125; override fun subList(fromIndex: Int, toIndex:Int): MutableList&lt;T&gt; &#123; return list.subList(fromIndex, toIndex) &#125; override fun add(element: T): Boolean &#123; return list.add(element) &#125; override fun add(index: Int, element: T) &#123; return list.add(index, element) &#125; override fun addAll(index: Int, elements: Collection&lt;T&gt;): Boolean &#123; return list.addAll(index, elements) &#125; override fun addAll(elements: Collection&lt;T&gt;): Boolean &#123; return list.addAll(elements) &#125; override fun clear() &#123; list.clear() &#125; override fun remove(element: T): Boolean &#123; return list.remove(element) &#125; override fun removeAll(elements: Collection&lt;T&gt;): Boolean &#123; return list.removeAll(elements) &#125; override fun removeAt(index: Int): T &#123; return list.removeAt(index) &#125; override fun retainAll(elements: Collection&lt;T&gt;): Boolean &#123; return list.retainAll(elements) &#125; override fun set(index: Int, element: T): T &#123; return list.set(index, element) &#125; override val size: Int get() = list.size override fun contains(element: T): Boolean &#123; return list.contains(element) &#125; override fun containsAll(elements: Collection&lt;T&gt;): Boolean &#123; return list.containsAll(elements) &#125; override fun get(index: Int): T &#123; return list[index] &#125; override fun indexOf(element: T): Int &#123; return list.indexOf(element) &#125; override fun isEmpty(): Boolean &#123; return list.isEmpty() &#125; override fun lastIndexOf(element: T): Int &#123; return list.lastIndexOf(element) &#125; @Valid val list: MutableList&lt;T&gt; = mutableListOf()&#125; 测试控制器 1234@PostMapping("/demoValidList1")fun demoValidList(@RequestBody @Validated user: ValidList1&lt;User&gt;): List&lt;User&gt;? &#123; return user.list&#125; 测试方法 1234567@Testfun testDemoValidList1() &#123; val example = "[&#123;\"username\":\"\", \"password\":\"111\"&#125;]" mockMvc.perform(MockMvcRequestBuilders.post("/demoValidList1") .contentType(MediaType.APPLICATION_JSON_VALUE).content(example)) .andExpect(status().isOk).andDo &#123; println(it.response.contentAsString) &#125;.andReturn()&#125; 使用kotlin委托我们可以节省部分代码(注意直接在list上增加@Valid是无效的) 委托器 12345class ValidList2&lt;T&gt;(val list: MutableList&lt;T&gt;) : MutableList&lt;T&gt; by list &#123; @Valid var mlist: MutableList&lt;T&gt; = list constructor() : this(mutableListOf())&#125; 控制器 1234@PostMapping("/demoValidList2")fun demoValidList2(@RequestBody @Validated user: ValidList2&lt;User&gt;): List&lt;User&gt;? &#123; return user.list&#125; 测试类 1234567@Testfun testDemoValidList2() &#123; val example = "[&#123;\"username\":\"\", \"password\":\"111\"&#125;]" mockMvc.perform(MockMvcRequestBuilders.post("/demoValidList2") .contentType(MediaType.APPLICATION_JSON_VALUE).content(example)) .andExpect(status().isOk).andDo &#123; println(it.response.contentAsString) &#125;.andReturn()&#125; 如果使用的是java我们也可以利用lombok替我们节省部分代码 12345@Datapublic class ValidList&lt;T&gt; implements List&lt;T&gt;&#123; @Delegate List&lt;T&gt; list = new ArrayList&lt;&gt;();&#125; 由于未做异常拦截,以上方案 正常校验,验证器将抛出异常方案1和方案2本质上是一致的,缺点在于对于控制器代码的侵入性较大(意味着所有需要校验list的控制器方法都需要修改类为新的包装类) 方案3 我们可以自定义验证器并配置@ControllerAdvice统一为集合增加验证器 自定义验证器 1234567891011121314151617181920212223class CollectionValidator(private val validatorFactory: LocalValidatorFactoryBean) : Validator &#123; override fun supports(clazz: Class&lt;*&gt;): Boolean &#123; return Collection::class.java.isAssignableFrom(clazz) &#125; /** * 校验集合 遇到失败即退出 * * @param target 受校验对象 * @param errors 错误结果 */ override fun validate(target: Any, errors: Errors) &#123; val collection = target as Collection&lt;*&gt; for (`object` in collection) &#123; `object`?.let &#123; ValidationUtils.invokeValidator(validatorFactory, `object`, errors) &#125; // 存在错误即退出校验 if (errors.hasErrors()) &#123; break &#125; &#125; &#125;&#125; 控制器拦截 1234567891011121314@ControllerAdviceclass CollectionValidatorAdvice(private val collectionValidator: CollectionValidator) &#123; /** * 在initBinder阶段修改集合类型的校验器 */ @InitBinder fun initBinder(binder: WebDataBinder) &#123; // 这里必须判断 否则会影响非集合类型校验 if (binder.target !is Collection&lt;*&gt;) &#123; return &#125; binder.addValidators(collectionValidator) &#125;&#125; 配置类 12345678910@Configurationclass CollectionValidatorConfig &#123; @Autowired lateinit var localValidatorFactoryBean: LocalValidatorFactoryBean @Bean fun collectionValidator(): CollectionValidator &#123; return CollectionValidator(localValidatorFactoryBean) &#125;&#125; 修改测试类,导入配置文件 1234@RunWith(SpringRunner::class)@WebMvcTest(DemoApplication::class)@Import(CollectionValidatorConfig::class)class WebMvcTest 再次运行testDemoList此时此方法将受校验 同样由于未做异常拦截,以上方案,验证器将抛出异常 方案3允许使用分组,对参数不需要做变更,而其缺陷在于如果想要知道是集合的哪条数据出现问题相对而言不太容易 代码链接]]></content>
      <categories>
        <category>kotlin web</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>gradle</tag>
        <tag>kotlin</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用gradle构建springboot项目]]></title>
    <url>%2F2019%2F03%2F03%2F%E4%BD%BF%E7%94%A8gradle%E6%9E%84%E5%BB%BAspringboot%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[使用gradle构建springboot项目 本文所用相关版本:springboot版本2.1.3.RELEASEkotlin版本1.3.21gradle版本5.2.1idea版本2018.2.6 ultimate edition 新建项目 点击file -&gt; new project -&gt; 选择新建gradle项目 输入groupId和artifactId 进入下一步 勾选使用本地gradle路径,选择gradle所在根路径(即bin的上层路径) 进入下一步 选择项目路径 点击finish等待项目构建完成 引入springboot 修改maven依赖访问地址,使用国内镜像 在build.gradle中加入 12345repositories &#123; maven&#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; &#125;&#125; 引入springboot 在plugins节点中加入 1id &apos;org.springframework.boot&apos; version &apos;2.1.3.RELEASE&apos; 加入根节点 使用spingboot插件(即最顶层) 1apply plugin: &apos;io.spring.dependency-management&apos; 引入springboot web和test依赖 在dependencies节点加入 12implementation &apos;org.springframework.boot:spring-boot-starter-web&apos;testImplementation &apos;org.springframework.boot:spring-boot-starter-test&apos; 新建启动类并测试 在java文件夹或kotlin文件夹下创建springboot启动类 1234567891011121314@SpringBootApplicationopen class SpringbootRun@RestControllerclass HelloController &#123; @GetMapping fun hello(): String &#123; return "hello" &#125;&#125;fun main() &#123; runApplication&lt;SpringbootRun&gt;()&#125; 点击右侧bootRun尝试启动(注意这里bootRun会自动扫描main方法,如果存在多个main方法只会选择其中一个),或者使用传统方式启动 访问localhost:8080查看结果 打成jar包并运行 点击右侧build下bootJar 项目下build/libs/将会生成一个jar包 使用命令行运行,并访问 打成war包并运行 修改build.gradle 加入根节点 1apply plugin: &apos;war&apos; 修改启动类使其继承SpringBootServletInitializer 12@SpringBootApplicationopen class SpringbootRun : SpringBootServletInitializer() 点击右侧bootWar 拷贝war包至tomcat安装路径webapps下 运行bin/startup.bat 启动tomcat并尝试访问 访问结果 打成war包使用jetty运行 修改build.gradle 加入根节点 123configurations &#123; compile.exclude module: "spring-boot-starter-tomcat"&#125; 加入依赖 1implementation &apos;org.springframework.boot:spring-boot-starter-jetty&apos; 点击右侧bootWar 拷贝war包至jetty安装路径webapps下 运行,并访问 1java -jar start.jar 访问结果: 代码链接]]></content>
      <categories>
        <category>kotlin web</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>kotlin</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis和redisson分布式锁集成]]></title>
    <url>%2F2019%2F01%2F20%2Fredis%E5%92%8Credisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[redis和redisson分布式锁集成 本文所用springboot版本2.1.2.RELEASEkotlin版本1.3.11 新建项目请参考springboot初探和配置文件映射 redis集成 新增依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 新增配置项 12345spring: redis: host: 127.0.0.1 port: 6379 timeout: 1000ms 配置redisTemplate 123456789101112131415161718192021222324252627@Configurationclass RedisConfig&#123; /** * 将redisTemplate格式化为string,any格式 * * @param factory redis连接工厂 * @return redisTemplate */ @Bean fun redisTemplate(factory: RedisConnectionFactory):RedisTemplate&lt;String,Any&gt; &#123; val template = RedisTemplate&lt;String,Any&gt;() template.setConnectionFactory(factory) val jackson2JsonRedisSerializer = Jackson2JsonRedisSerializer(Any::class.java) val om = ObjectMapper() om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY) om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL) jackson2JsonRedisSerializer.setObjectMapper(om) val stringRedisSerializer = StringRedisSerializer() template.keySerializer = stringRedisSerializer template.hashKeySerializer = stringRedisSerializer template.valueSerializer = jackson2JsonRedisSerializer template.hashValueSerializer = jackson2JsonRedisSerializer template.afterPropertiesSet() return template &#125;&#125; 新建测试类,继承生成的测试类,并运行 1234567891011121314151617class RedisTest : KotlinSpringbootApplicationTests() &#123; private val log = LoggerFactory.getLogger(this.javaClass) private val testKey = this.javaClass.name @Autowired lateinit var redisTemplate: RedisTemplate&lt;String, Any&gt; @Test fun testString() &#123; log.info("---设置值---") redisTemplate.opsForValue().set(testKey, "hello") val str = redisTemplate.opsForValue().get(testKey) as? String log.info("---打印值:$str---") redisTemplate.delete(testKey) &#125;&#125; 尝试进行对象存储 1234567891011data class User(val username:String, val sex:String,val phone:Long)//新增测试类@Testfun testAny() &#123; val user = User("maple","man",18011111111) log.info("---设置对象---") redisTemplate.opsForValue().set(testKey, user) val user = redisTemplate.opsForValue().get(testKey) as? User log.info("---打印值:$user---") redisTemplate.delete(testKey)&#125; 我们会发现当前的序列化工具对于kotlin对象的序列化并不是那么理想,我们需要重写一个序列化工具 方式1:使用hessian帮助我们进行序列化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//依赖&lt;hessian.vesion&gt;4.0.51&lt;/hessian.vesion&gt;&lt;dependency&gt; &lt;groupId&gt;com.caucho&lt;/groupId&gt; &lt;artifactId&gt;hessian&lt;/artifactId&gt; &lt;version&gt;$&#123;hessian.vesion&#125;&lt;/version&gt;&lt;/dependency&gt;//序列化工具包object SerializeUtils&#123; @Throws(IOException::class) fun hessianDeserialize(by: ByteArray?): Any &#123; by?: throw NullPointerException() return hessianDeserialize(ByteArrayInputStream(by)) &#125; @Throws(IOException::class) fun hessianDeserialize(input:InputStream): Any&#123; return HessianInput(input).readObject() &#125; fun hessianSerialize(obj: Any?): ByteArray &#123; obj?: throw NullPointerException() try &#123; val os = ByteArrayOutputStream() val ho = HessianOutput(os) ho.writeObject(obj) return os.toByteArray() &#125; catch (e: Exception) &#123; throw e &#125; &#125; @Throws(IOException::class) fun hessianSerialize(obj: Any,out:OutputStream)&#123; HessianOutput(out).writeObject(obj) &#125; fun javaSerialize(obj: Any?):ByteArray&#123; obj?: throw NullPointerException() val os = ByteArrayOutputStream() val out = ObjectOutputStream(os) out.writeObject(obj) return os.toByteArray() &#125; fun javaSerialize(by: ByteArray?):Any&#123; by?: throw NullPointerException() val `is` = ByteArrayInputStream(by) val `in` = ObjectInputStream(`is`) return `in`.readObject() &#125;&#125; 新建类实现RedisSerializer(对象需要实现序列化)并修改redis配置 12345678910111213141516171819202122232425262728class HessianRedisSerializer&lt;T&gt;(private var clazz: Class&lt;T&gt;) : RedisSerializer&lt;T&gt;&#123; override fun serialize(t: T?): ByteArray? &#123; return SerializeUtils.hessianSerialize(t) &#125; override fun deserialize(bt: ByteArray?): T? &#123; if(bt == null || bt.isEmpty()) return null @Suppress("UNCHECKED_CAST") return SerializeUtils.hessianDeserialize(bt) as? T &#125;&#125;//redis配置@Beanfun redisTemplate(factory: RedisConnectionFactory):RedisTemplate&lt;String,Any&gt; &#123; val template = RedisTemplate&lt;String,Any&gt;() template.setConnectionFactory(factory) val hessianRedisSerializer = HessianRedisSerializer(Any::class.java) val stringRedisSerializer = StringRedisSerializer() template.keySerializer = stringRedisSerializer template.hashKeySerializer = stringRedisSerializer template.valueSerializer = hessianRedisSerializer template.hashValueSerializer = hessianRedisSerializer template.afterPropertiesSet() return template&#125;//修改实体类 让实体类实现序列化接口data class User(val username:String, val sex:String,val phone:Long):Serializable 再次测试,存取成功 方式2,使用java 对象输入输出流实现(对象需要实现序列化) 比较慢 不推荐 123456789101112class HessianRedisSerializer&lt;T&gt;(private var clazz: Class&lt;T&gt;) : RedisSerializer&lt;T&gt;&#123; override fun serialize(t: T?): ByteArray? &#123; return SerializeUtils.hessianSerialize(t) &#125; override fun deserialize(bt: ByteArray?): T? &#123; if(bt == null || bt.isEmpty()) return null @Suppress("UNCHECKED_CAST") return SerializeUtils.hessianDeserialize(bt) as? T &#125;&#125; 方式3,使用fastjson,对象可以不用实现序列化123456789101112131415161718192021222324252627282930313233343536373839//依赖&lt;fast-json.vesion&gt;1.2.54&lt;/fast-json.vesion&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fast-json.vesion&#125;&lt;/version&gt;&lt;/dependency&gt;//序列化类class FastJsonRedisSerializer&lt;T&gt;(private val clazz:Class&lt;T&gt; ) : RedisSerializer&lt;T&gt;&#123; private val charset = Charset.forName("utf-8")!! override fun serialize(t: T?): ByteArray? &#123; return JSON.toJSONString(t, SerializerFeature.WriteClassName).toByteArray(charset) &#125; override fun deserialize(bt: ByteArray?): T? &#123; if(bt == null || bt.isEmpty()) return null val str = String(bt, charset) return JSON.parseObject&lt;T&gt;(str, clazz) &#125;&#125;//配置@Beanfun redisTemplate(factory: RedisConnectionFactory):RedisTemplate&lt;String,Any&gt; &#123; val template = RedisTemplate&lt;String,Any&gt;() template.setConnectionFactory(factory) var fastJsonRedisSerializer = FastJsonRedisSerializer(Any::class.java) //配置白名单 ParserConfig.getGlobalInstance().addAccept("com.maple.kotlinspringboot.entity.User") //或者直接关闭这个检测 //ParserConfig.getGlobalInstance().isAutoTypeSupport = true val stringRedisSerializer = StringRedisSerializer() template.keySerializer = stringRedisSerializer template.hashKeySerializer = stringRedisSerializer template.valueSerializer = fastJsonRedisSerializer template.hashValueSerializer = fastJsonRedisSerializer template.afterPropertiesSet() return template&#125; 做一个简单的redis工具包 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@Componentclass RedisUtils &#123; @Autowired lateinit var redisTemplate: RedisTemplate&lt;String, Any&gt; /** * 获取指定缓存对象 * * @param key 键 * @return any 值对象 */ fun &lt;T : Any&gt; getT(key: String):T? &#123; @Suppress("UNCHECKED_CAST") return redisTemplate.opsForValue().get(key) as? T &#125; /** * 获取long值 * * @param key 键 * @return any 值对象 */ fun getLong(key: String):Long?&#123; val value = getAny(key) return when(value)&#123; is Byte -&gt; value.toLong() is Int -&gt; value.toLong() is Long -&gt; value is Float -&gt; value.toLong() is Double -&gt; value.toLong() is Char -&gt; value.toLong() is String -&gt; value.toLongOrNull() else -&gt; null &#125; &#125; /** * 获取int值 * * @param key 键 * @return any 值对象 */ fun getInt(key: String):Int?&#123; val value = getAny(key) return when(value)&#123; is Byte -&gt; value.toInt() is Int -&gt; value is Long -&gt; value.toInt() is Float -&gt; value.toInt() is Double -&gt; value.toInt() is Char -&gt; value.toInt() is String -&gt; value.toIntOrNull() else -&gt; null &#125; &#125; /** * 存入普通缓存对象 * * @param key 键 * @param value 值对象 * @return Boolean 是否成功 */ fun setAny(key:String,value:Any) &#123; redisTemplate.opsForValue().set(key,value) &#125; /** * 删除普通缓存对象 * * @param key 键 * @return Boolean 是否成功 */ fun delete(key:String):Boolean &#123; return redisTemplate.delete(key) &#125; /** * 获取普通缓存对象 * * @param key 键 * @return any 值对象 */ private fun getAny(key: String):Any? &#123; return redisTemplate.opsForValue().get(key) &#125;&#125; redisson集成 引入依赖 123456&lt;redisson.version&gt;3.10.0&lt;/redisson.version&gt;&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;$&#123;redisson.version&#125;&lt;/version&gt;&lt;/dependency&gt; 配置bean 12345678910@Autowiredlateinit var redisProperties: RedisProperties@Beanfun redisClient(): RedissonClient &#123; val serverConfig = Config().apply &#123; this.useSingleServer() .setAddress("redis://$&#123;redisProperties.host&#125;:$&#123;redisProperties.port&#125;").timeout = (redisProperties.timeout.seconds * 1000).toInt() &#125; return Redisson.create(serverConfig)&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738394041class RedisLockTest : BaseTest()&#123; private val log = LoggerFactory.getLogger(this.javaClass) private val testRedisKey = this.javaClass.name private val lockKey = "testLockKey" @Autowired lateinit var redisUtils: RedisUtils @Autowired lateinit var redisClient: RedissonClient @Before fun setUp() &#123; log.info("----------before-----------") &#125; @After fun tearDown() &#123; log.info("----------after-----------") &#125; @Test fun setInt()&#123; redisUtils.setAny(testRedisKey,100) println(redisUtils.getInt(testRedisKey)) &#125; @Test fun testLock()&#123; val lock:RLock = redisClient.getLock(lockKey) println("---尝试上锁---") lock.tryLock(20, TimeUnit.SECONDS) println("---进入循环---") for (i in 0..10)&#123; val stock = redisUtils.getInt(testRedisKey) Thread.sleep(1000) if(stock!! &gt; 0)&#123; redisUtils.setAny(testRedisKey, value = stock-1) println("stock: $stock-1") &#125; &#125; lock.unlock() &#125;&#125; 先执行一次设值,再同时运行两次测试类,我们希望达到的效果是,当第一个执行完循环时,第二个才开始进入循环,可以看到,最终结果确如我们所愿 注解获取缓存对象 不论我们使用shiro,还是security或是其他的框架做项目的权限控制,我们可能需要将用户存入缓存中,这里我使用注解获取缓存中的用户对象 新建一个注解类 123@Target(AnnotationTarget.VALUE_PARAMETER)@Retention(AnnotationRetention.RUNTIME)annotation class CurrentUser 新建一个方法解析器 1234567891011121314@Componentclass CurrentUserMethodArgumentResolver:HandlerMethodArgumentResolver&#123; @Autowired lateinit var redisUtils: RedisUtils override fun supportsParameter(parameter: MethodParameter): Boolean &#123; return parameter.parameterType.isAssignableFrom(User::class.java) &amp;&amp; parameter.hasParameterAnnotation(CurrentUser::class.java) &#125; override fun resolveArgument(parameter: MethodParameter, mavContainer: ModelAndViewContainer?, webRequest: NativeWebRequest, binderFactory: WebDataBinderFactory?): Any? &#123; return redisUtils.getT&lt;User&gt;("currentUser") &#125;&#125; 修改spring配置 1234567891011121314@Configurationclass SpringConfig : WebMvcConfigurer &#123; @Autowired lateinit var currentUserResolver: CurrentUserMethodArgumentResolver override fun addViewControllers(registry: ViewControllerRegistry) &#123; registry.addViewController("/").setViewName("forward:/hello") registry.setOrder(Ordered.HIGHEST_PRECEDENCE) &#125; override fun addArgumentResolvers(resolvers: MutableList&lt;HandlerMethodArgumentResolver&gt;) &#123; super.addArgumentResolvers(resolvers) resolvers.add(currentUserResolver) &#125;&#125; 修改控制层 12345678910111213141516@RestControllerclass HelloController &#123; @Autowired lateinit var redisUtils: RedisUtils @GetMapping("/hello") fun hello(@CurrentUser user:User): String &#123; return user.toString() &#125; @GetMapping("/testLogin") fun testLogin(user:User): String &#123; redisUtils.setAny("currentUser",user) return "success" &#125;&#125; 依次运行http://localhost:9001/testLogin?username=me&amp;sex=man&amp;phone=1000http://localhost:9001/hello可以看到我们成功取到了这个对象 代码链接回到顶部]]></content>
      <categories>
        <category>kotlin web</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>kotlin</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot初探和配置文件映射]]></title>
    <url>%2F2019%2F01%2F15%2Fspringboot%E5%88%9D%E6%8E%A2%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[springboot初探和配置文件映射 本文所用springboot版本2.1.2.RELEASEkotlin版本1.3.11 新建项目 选择Spring Initializr 在metadata页面中选择kotlin作为语言 依赖勾选web 将kotlin文件夹设为项目资源文件夹,并等待项目依赖下载完毕 新建测试控制器并设置/hello为默认映射路径 123456789101112131415@Configurationclass SpringConfig : WebMvcConfigurer &#123; override fun addViewControllers(registry: ViewControllerRegistry) &#123; registry.addViewController("/").setViewName("forward:/hello") registry.setOrder(Ordered.HIGHEST_PRECEDENCE) &#125;&#125;@RestControllerclass HelloController &#123; @GetMapping("/hello") fun hello(): String &#123; return "hello" &#125;&#125; 启动项目访问页面 读取配置文件 新建配置文件test.yml,并添加几个值(如果需要yml配置文件的提示可以安装spring assistant插件,或者点项目配置将其加入配置列表) 123456789101112131415person: name: maple sex: man phone: 18111111111 children: &#123;name: merry,sex: woman&#125; lists: - 1 - 2// 如果需要使用传统properties配置需要引入依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 修改控制器为属性注入值,注意由于kotlin字符串中的$本身有其含义,因此需要加反斜杠转义 1234567@Value("\$&#123;person.name&#125;")private lateinit var username:String@GetMapping("/hello")fun hello(): String &#123; return "hello $username"&#125; 访问项目 实体映射,由于默认的工厂对自定义yml解析有问题,新建映射工厂类解析yml,新建实体并修改控制器(如果需要使用kotlin中的data类型 需要手动注bean) 123456789101112131415161718192021222324252627282930313233343536373839//解析工厂class YamlPropertySourceFactory : PropertySourceFactory &#123; @Throws(IOException::class) override fun createPropertySource(name: String?, resource: EncodedResource): PropertySource&lt;*&gt; &#123; return if (name != null) YamlPropertySourceLoader().load(name, resource.resource)[0] else YamlPropertySourceLoader().load( getNameForResource(resource.resource), resource.resource)[0] &#125; private fun getNameForResource(resource: Resource): String &#123; var name = resource.getDescription() if (!StringUtils.hasText(name)) &#123; name = resource::class.java.getSimpleName() + "@" + System.identityHashCode(resource) &#125; return name &#125;&#125;//映射类@Configuration@ConfigurationProperties(prefix = "person")@PropertySource("classpath:/test.yml",factory = YamlPropertySourceFactory::class)class UserProperties &#123; lateinit var name: String lateinit var sex: String var phone = 0L lateinit var children: Map&lt;String,String&gt; lateinit var lists: List&lt;String&gt; override fun toString():String&#123; return "name:$name,sex:$sex,phone:$phone,children:$children,lists:$lists" &#125;&#125;//修改 controller@Autowiredprivate lateinit var userProperties:UserProperties@GetMapping("/hello")fun hello(): String &#123; return userProperties.toString()&#125; 启动测试 另:使用kotlin data class类型注入(对于map类型的属性暂时没有找到特别好的办法解决) 12345678910111213141516171819//修改映射类@Configuration@PropertySource("classpath:/test.yml",factory = YamlPropertySourceFactory::class)data class UserProperties(@Value("\$&#123;person.name&#125;")val name:String, @Value("\$&#123;person.sex&#125;")val sex:String, @Value("\&#123;person.phone&#125;")val phone:Long)//注,由于@value注解本身对于list map的支持并非很友好 因此并不推荐//配置listlist: 1,2//取值注入@Value("#&#123;'\$&#123;person.lists&#125;'.split(',')&#125;")private lateinit var lists:List&lt;String&gt;//或者激活支持转换String为Collection类型的新配置服务@Beanfun conversionService(): ConversionService&#123; return DefaultConversionService()&#125;//这时list将不用再特殊处理 但配置仍旧只能保持字符串形式@Value("\$&#123;person.lists&#125;")private lateinit var lists:List&lt;String&gt; 代码链接]]></content>
      <categories>
        <category>kotlin web</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>kotlin</tag>
        <tag>web</tag>
      </tags>
  </entry>
</search>
